# 网络详解

## 一、概述

计算机之间通信是依靠互联网，互联网的核心是一系列协议。

### 1、协议

协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。它最终体现为在网络上传输的数据包的格式。

### 2、分层体系结构

协议往往分成几个层次进行定义，分层定义是为了层与层之间解耦，互不影响，职责清晰，提高兼容性，方便技术创新。

OSI参考模型与TCP/IP模型都采用了分层体系结构，将庞大而复杂的问题转化为若干个较小且易于处理的子问题。

OSl参考模型划分7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

TCP/IP参考模型最多划分了5个层次，分别是物理层，数据链路层、网络层、传输层和应用层，将OSI参考模型中的高三层合并为一层统称应用层。

![](D:\TechLearn-master\img\网络协议\202201232201582.jpg)

### 3、层次关系

用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解。

![1036857-20200415215541847-564448301](../img/网络协议/202201232201572.gif)

### 4、每层运行常见物理设备

![1036857-20161008144925254-1398507493](../img/网络协议/202201232201095.Jpg)

## 二、物理层

### 1、物理层的意义

电脑要通信，当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。**这就叫做"物理层"，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。**

![img](../img/网络协议/202201232201714.png)

### 2、集线器工作原理

网络上不可能只有两台机器在通信，这时候如果加入一台机器，就需要每台机器开两个网口，用一共三根网线，彼此相连。

![1096103-20210112113222683-1929492571](../img/网络协议/202201232219301.png)

随着越来越多的机器加入，你发现机器上开的网口越来越多，而且网线密密麻麻，混乱不堪，实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行。

![1096103-20210112113229408-608147059](../img/网络协议/202201232221358.png)

于是发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，转换了一种形式，不再那么混乱。我们给它取名叫**集线器**，它仅仅是无脑将电信号**转发到所有出口（广播）**，因此把**集线器**定性在了**物理层**。

![下载](../img/网络协议/202201232224444.gif)

由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？于是出现了数据链路层。

## 三、数据链路层

### 1、数据链路层由来

数据链路层由来：单纯的0和1没有任何意义，必须规定电信号多少位一组，每组什么意思。

数据链路层的功能：定义了电信号的分组方式

### 2、以太网协议

早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做["以太网"](https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91)（Ethernet）的协议，占据了主导地位。

以太网规定：

- 一组电信号构成一个数据包，叫做"帧"（Frame）。
- 每一帧分成两个部分：标头（Head）和数据（Data）。

![img](../img/网络协议/202201232201363.png)

Head，固定为18字节，包含：

- 发送者／源地址，6个字节
- 接收者／目标地址，6个字节
- 数据类型，6个字节

data，最短46字节，最长1500字节，包含：

- 数据包的具体内容

head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送

### 3、MAC地址

上面提到，Head包含了发送者和接受者的信息。以太网规定，连入网络的所有设备，都必须具有"网卡"。发送端和接收端的地址便是指网卡的地址，即mac地址。

![1096103-20210112180112546-2060866082](../img/网络协议/202201242156199.png)

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。

![img](../img/网络协议/202201232201144.png)

### 4、广播

有了MAC地址，两台机器就可以进行通信了。以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方，这就是广播。

A 在发送数据包给 B 时，头部Head包含了发送者和接受者的信息，B 在收到数据包后，根据头部的目标 MAC 地址判断这个数据包是发给自己的就**收下**。其他的 CDE 收到数据包后，根据头部的目标 MAC 地址判断这个数据包并不是发给自己的就**丢弃**。

![img](../img/网络协议/202201242202142.gif)

虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，既不安全，又浪费网络资源。如果把这个集线器弄得更智能一些，**只发给目标MAC地址的电脑**，就好了。

![img](../img/网络协议/202201242205822.gif)

### 5、交换机工作原理

虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做**交换机**。也正因为这一点点智能，你把它放在了另一个层级，**数据链路层**。

 ![img](../img/网络协议/202201242205746.png)

交换机内部维护一张 **MAC 地址表**，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。假如你仍然要发给 B 一个数据包，到达交换机时，查找交换机内部的MAC地址表，发现B的MAC地址对应端口1，于是把数据从 1 号端口发给了 B，就结束了。

#### MAC地址表是如何建立的

1. 最开始的时候，MAC地址表是空的。
2. 现在A给B发送数据，由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据，**MAC：aa-aa-aa-aa-aa-aa-aa端口：4**。
3. 交换机看目标MAC地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了**所有端口**，也即发给了所有机器，只有机器B收到了确实是发给自己的包，于是做出了**响应**，响应数据从端口1进入交换机，于是交换机此时在地址表中更新了第二条数据，**MAC：bb-bb-bb-bb-bb-bb端口：1**。
4. 经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕。

### 6、交换机的局限

随着机器数量越多，交换机的端口也不够了，但只要将多个交换机连接起来，这个问题就轻而易举搞定。

![img](../img/网络协议/202201242236402.png)

你完全不需要设计额外的东西，按照上述的接线方式即可完成所有电脑的互联。但是要注意，上面那根红色的线在 MAC 地址表中可不是一条记录，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。最终，**两个交换机将分别记录 A ~ H 所有机器的映射记录**。

**左边的交换机**

| MAC 地址              | 端口  |
| --------------------- | ----- |
| bb-bb-bb-bb-bb-bb     | 1     |
| cc-cc-cc-cc-cc-cc     | 3     |
| aa-aa-aa-aa-aa-aa     | 4     |
| dd-dd-dd-dd-dd-dd     | 5     |
| **ee-ee-ee-ee-ee-ee** | **6** |
| **ff-ff-ff-ff-ff-ff** | **6** |
| **gg-gg-gg-gg-gg-gg** | **6** |
| **hh-hh-hh-hh-hh-hh** | **6** |

**右边的交换机**

| MAC 地址              | 端口  |
| --------------------- | ----- |
| **bb-bb-bb-bb-bb-bb** | **1** |
| **cc-cc-cc-cc-cc-cc** | **1** |
| **aa-aa-aa-aa-aa-aa** | **1** |
| **dd-dd-dd-dd-dd-dd** | **1** |
| ee-ee-ee-ee-ee-ee     | 2     |
| ff-ff-ff-ff-ff-ff     | 3     |
| gg-gg-gg-gg-gg-gg     | 4     |
| hh-hh-hh-hh-hh-hh     | 6     |

这在只有 8 台电脑甚至只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。但很遗憾，电脑的数量很快就发展到几万，几十万，几百万。交换机已经无法记录如此庞大的映射关系了。

问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得MAC地址表越来越大，不可控。那我可不可以让那根红色的网线，接入一个**新的设备**，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次**转发**，这样，一个端口对应的MAC就会固定成一个，MAC地址表的大小就是可控的。

这个设备就是**路由器，**它的功能就是，作为一台独立的拥有MAC地址的设备，并且可以把数据包做一次转发，把它定在了**网络层。**

路由器的每一个端口，都有独立的 MAC 地址。现在交换机的MAC地址表中，只需要多出一条MAC地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器。

![img](../img/网络协议/202201261022266.png)

## 四、网络层

### 1、网络层由来

#### 为什么要划分子网？

有了以太网、MAC地址、广播的发送方式，理论上世界上的计算机就可以彼此通信了，问题是如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，这就不仅仅是效率低的问题了，这会是一种灾难。

必须将一个巨大的互联网拆分成无数个子网，让广播的范围减小，提高网络效率。必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，就采用路由的方式（向不同广播域／子网分发数据包）。

![img](../img/网络协议/202201261322381.png)

#### 为什么要引入IP地址？

MAC地址是无法区分的，它只跟厂商有关，与所处网络无关。如果你希望使用MAC 地址来区分网络，就需要某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变，这基本是不现实的。

**这就导致了"网络层"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫"网络地址"也叫做"IP地址"。MAC 地址一般是无法修改的，IP地址可以修改。**

### 2、IP协议

- 规定IP地址的协议叫IP协议，它定义的地址称之为IP地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示。

- 范围0.0.0.0-255.255.255.255。

- 一个IP地址通常写成四段十进制数，例：172.16.10.1。

- IP地址分成两个部分，【网络部分（区分不同子网），主机部分（区分子网中的主机）】。

  ![img](../img/网络协议/202201251048886.png)

#### IP数据包

根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为head和data部分，无须为IP包定义单独的栏位，直接放入以太网包的data部分。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。

- head：长度为20到60字节
- data：最长为65,515字节。

而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。

![img](../img/网络协议/202201251124068.png)

### 3、路由器工作原理

我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址

![img](../img/网络协议/202201261331167.png)

现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。

![img](../img/网络协议/202201251724545.png)

但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。

A到路由器这段的包如下：

![img](../img/网络协议/202201261331483.png)

路由器到 C 这段的包如下：

![img](../img/网络协议/202201261331388.png)

好了，上面说的两种情况（A->B，A->C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。

### 4、子网掩码

A 给 C 发数据包，怎么知道是否要通过路由器转发呢？

答案是子网，如果源IP与目的IP处于一个子网，数据包直接走交换机。不处于一个子网，就走路由器。现在只需要解决怎么判断源IP与目的IP处于一个子网就好了。

单纯的从IP地址无法判断，区分子网需要另一个参数"子网掩码"。子网掩码是表示子网络特征的一个参数，形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。例如网络长度是24的子网掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

收发双方两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

假如某台机器的子网掩码定为 255.255.255.0，比如：

- **A电脑**：192.168.0.1 & 255.255.255.0 = 192.168.0.0
- **B电脑**：192.168.0.2 & 255.255.255.0 = 192.168.0.0
- **C电脑**：192.168.1.1 & 255.255.255.0 = 192.168.1.0
- **D电脑**：192.168.1.2 & 255.255.255.0 = 192.168.1.0

那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，以此类推。所以如果 A 给 C 发消息， A 和 C 不在同一个子网，于是把包发给路由器。

![img](../img/网络协议/202201251724842.png)

### 5、默认网关

A如何知道，哪个设备是路由器？

答案是在A上要设置**默认网关**，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。所以**默认网关，就是 A 在自己电脑里配置的一个 IP 地址**，以便在发给不同子网的机器时，发给这个 IP 地址。

![img](../img/网络协议/202201261331115.png)

### 6、路由表

路由器如何知道C在哪？

答案是**路由表**，现在 A 要给 C 发数据包，已经成功发到路由器，路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，应该有个表，就像 MAC 地址表一样，这个表就叫**路由表**。

不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。

| 目的地址      | 子网掩码        | 下一跳 | 端口 |
| ------------- | --------------- | ------ | ---- |
| 192.168.0.0   | 255.255.255.0   |        | 0    |
| 192.168.0.254 | 255.255.255.255 |        | 0    |
| 192.168.1.0   | 255.255.255.0   |        | 1    |
| 192.168.1.254 | 255.255.255.255 |        | 1    |

由于子网掩码其实就表示前多少位是子网的网段，所以 192.168.0.0（255.255.255.0）可以简写为 192.168.0.0/24

| 目的地址         | 下一跳 | 端口 |
| ---------------- | ------ | ---- |
| 192.168.0.0/24   |        | 0    |
| 192.168.0.254/32 |        | 0    |
| 192.168.1.0/24   |        | 1    |
| 192.168.1.254/32 |        | 1    |

这个路由表就表示，**192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口**。

### 7、ARP协议

上面说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？

答案是**ARP协议**，可以根据IP地址找到MAC地址，同时机器上会有一张 **ARP缓存表**，表中记录着 **IP 与 MAC 地址**的对应关系。

#### ARP协议工作原理

ARP协议使用广播的方式发送数据包，其中包含目标主机的IP地址，在目标主机MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个"广播"地址。

它所在子网络的每一台主机，都会收到这个数据包，如果目标IP地址与自身的IP地址相同就做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。发送方和目标主机都可以更新本机的ARP缓存表。

这样通过大家不断广播ARP请求，最终所有电脑里面都将 arp 缓存表更新完整。

## 五、完整过程

A 给 F 发送一个数据包的整个过程是怎样的呢？

![img](../img/网络协议/202201261636174.png)

路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。

| 目的地址         | 下一跳        | 端口 |
| ---------------- | ------------- | ---- |
| 192.168.0.0/24   |               | 0    |
| 192.168.0.254/32 |               | 0    |
| 192.168.1.0/24   |               | 1    |
| 192.168.1.254/32 |               | 1    |
| 192.168.2.0/24   | 192.168.100.5 |      |
| 192.168.100.0/24 |               | 2    |
| 192.168.100.4/32 |               | 2    |

#### 数据包流转详细过程

1.  A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网，于是决定将数据包发送给默认网关（192.168.0.254）。查看其 arp 缓存，找到 默认网关 192.168.0.254 的 MAC 地址（ABAB）将其封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）封装在网络层头部，然后发包。![img](../img/网络协议/202201261638840.png)
2. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，将数据包发给路由器1。
3. 路由器 1 收到数据包后，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是192.168.100.5，再次匹配路由表，发现匹配到了端口为 2，查看其 arp 缓存，找到路由器2 192.168.100.5的MAC 地址为 D2D2，将其封装在数据链路层头部，并从 2 号端口把包发出去。
4. 路由器 2 收到数据包后，发现其目标 IP 地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，查看其 arp 缓存，找到目标IP 192.168.2.2的MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。
5. 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，匹配到端口号为 6，于是从 6 号端口把数据包发出去。
6. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包。

## 六、传输层

### 1、传输层由来

网络层的IP帮我们区分子网，以太网层的MAC帮我们找到主机，但是同一台主机上有许多程序进程，区分不同的程序需要一个新的参数**端口**，它其实就是给每一个进程的编号，每个数据包都发到主机的特定端口也就是特定的进程。

至此，发送的数据包上，增加了传输层的头部，源端口号与目标端口号。

![421ccb63-c23d-4c56-b70f-f3e932d2f3c8](../img/网络协议/202201261615264.png)

端口范围0到65535，0-1023的端口被系统占用，用户只能用大于1023的端口。

**"传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。**

### 2、UDP协议

现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议。

UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好能放进一个IP数据包。

### 3、TCP协议

UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。有可能丢包。

为了解决这个问题，提高网络可靠性，TCP协议就诞生了。它就是有确认机制的UDP协议，每发出一个数据包都要求确认，一旦数据包遗失，就收不到确认，发出方就会重发。它的缺点是过程复杂、实现困难、消耗较多的资源。

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。

## 七、应用层

### 1、应用层由来

应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

**"应用层"的作用，就是规定应用程序的数据格式。**

TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。常见的应用层协议有http，ftp，smtp等。

这是最高的一层，直接面对用户。它的数据就放在TCP数据包的"数据"部分。因此，现在的以太网的数据包就变成下面这样。

![bg2012052913](../img/网络协议/202201281413625.png)

### 2、ftp协议

FTP（File Transfer Protocol）协议，文件传输协议。提供交互式的访问，对传输文件的格式和类型有分类，允许文件具有存取权限。适合异构网络任意计算机的传送。

### 3、http协议

HTTP （HyperText Transfer Protocol），超文本传输协议，基于TCP/IP通信协议。是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。

### 4、socket

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种"打开—读/写—关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

## 八、访问网页

你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？

通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：

- 本机的IP地址
- 子网掩码
- 网关的IP地址
- DNS的IP地址

下图是Windows系统的设置窗口，这四个参数缺一不可。

![img](../img/网络协议/202201271047335.png)

### 1、静态IP地址

由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作"静态IP地址上网"。

但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用"动态IP地址上网"。

### 2、动态IP地址

所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做[DHCP协议](https://zh.wikipedia.org/zh/DHCP)。

### 3、DHCP协议

DHCP协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。

前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？

#### DHCP协议数据包

首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包如下，DHCP协议做了一些巧妙的规定。

![img](../img/网络协议/202201271106355.png)

- 以太网标头：设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。

- IP标头：设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。

- UDP标头：设置发出方的端口68和接收方的端口67，这一部分是DHCP协议规定好的。

#### DHCP协议工作原理

1. 以太网是广播发送数据包，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，必须继续分析这个包的IP地址，当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。

2. DHCP服务器分配好IP地址后，响应一个"DHCP"数据包。这个响应包的结构也是类似的，以太网标头设置的MAC地址是双方的网卡地址，IP标头设置的发出方是DHCP服务器IP地址和接收方是255.255.255.255，UDP标头的设置发出方端口是67和接收方端口68，分配给请求端的IP地址和本网络的具体参数则包含在Data部分。

3. 新加入的计算机收到这个响应包，判断出MAC地址和自己相符就收下此包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。


### 4、DNS协议

#### （1）DNS 是什么

IP地址对于用户来说不方便记忆，于是发明了域名，例如www.baidu.com这是百度的域名，但是互联网通信必须要知道对方的IP地址，很多时候我们只知道域名，不知道它的IP地址。

首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。

DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在`/etc/resolv.conf`文件。

域名多如繁星，所以存在一台服务器上是不可能的，域名是按照层级进行划分的，所以域名解析也是分级查询的。

#### （2）域名的层级

举例来说，`www.example.com`真正的域名是`www.example.com.root`，简写为`www.example.com.`。因为，根域名`.root`对于所有域名都是一样的，所以平时是省略的。

根域名的下一级，叫做"顶级域名"（top-level domain，缩写为TLD），比如`.com`、`.net`；再下一级叫做"次级域名"（second-level domain，缩写为SLD），比如`www.example.com`里面的`.example`，这一级域名是用户可以注册的；再下一级是主机名（host），比如`www.example.com`里面的`www`，又称为"三级域名"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

总结一下，域名的层级结构如下。

```bash
主机名.次级域名.顶级域名.根域名
#即
host.sld.tld.root
```

#### （3）DNS解析过程，以Chrome为例

> 实际的域名解析，除了查询域名服务器，还有各种缓存的使用，用以提高查询性能。

1. Chrome浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），如果有且没有过期则解析结束。我们怎么查看Chrome自身的缓存？可以使用chrome://net-internals/#dns 来进行查看。
2. 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存，如果找到且没有过期则解析结束。怎么查看操作系统自身的DNS缓存？以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看。
3. 如果操作系统的DNS缓存也没有找到，那么尝试读取hosts文件（wondows位于C:\Windows\System32\drivers\etc\hosts，linux位于/etc/hosts），如果找到解析结束。
4. 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，向本地配置的首选DNS服务器发起域名解析请求，DNS服务器首先查找自身的缓存，找到则解析结束。
5. DNS服务器自身的缓存没有找到，则DNS服务器首先找到本机内置（几乎不会变更，所以是直接内置的）的13台根域名服务器的IP地址，再从"根域名服务器"查到"顶级域名服务器"IP地址，再从"顶级域名服务器"查到"次级域名服务器"IP地址，再从"次级域名服务器"查出"主机名"的IP地址，则解析结束。

### 5、一个完整的访问网页的过程

1. 在google浏览器输入一个域名回车。
2. 浏览器先DNS域名解析成IP地址。
3. 将请求信息封装成http数据包，发送给集线器，交换机，路由器最终到达网址对应IP的服务器。
4. 服务器接收到请求，进行处理，将返回值封装成http数据包。
5. 数据包经过集线器，交换机，路由器最终回到浏览器。
6. 浏览器将返回的内容解析成网页内容呈现到你面前。
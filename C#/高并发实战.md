秒杀系统的特点：

秒杀是一件商品的购买人数远远大于这件商品的库存

秒杀的本质是高性能、高一致、高可用

在双十一的零点，有大量的同时用户访问网站，瞬间并发峰值非常高，系统中商品页的访问量过大，（读多写少）

架构的演进：

数据库和web服务器（应用程序）部署在同一台服务器；缺点：当访问量大时，数据库和Web服务器会争抢资源，导致性能底下

数据库和Web服务器分开部署，问题：当数据库数据量太大时，并发读写数据库成为瓶颈，数据库扛不住压力

在上面的基础上，增加Web服务器的本地缓存和分布式缓存，问题：缓存穿透，击穿，缓存雪崩，热点数据集中失效，缓存不一致

在上面的基础上，当数据过大时，数据库抗住了压力，但是Web服务器会因为访问次数过多，导致响应速度变慢，可以通过反向代理（Nginx）均匀发的分发到每个Web服务器上

虽然通过反向代理解决了Web服务器的并发问题，但是高并发说明了更多的请求穿透到数据库中，一般采用读写分离的方式，来解决单机数据库的瓶颈；还可以使用消息队列，使并发请求的到平缓处理

秒杀流程：

## 思路

商品秒杀是典型的高并发场景,为了提高性能,减少数据库的访问次数可以把数据加载到redis中,在redis中进行商品的库存减少,而且不会存在线程安全问题,当redis中商品减少成功后,可以把消息推送到rabbitMQ中,实现异步同步到数据库,让数据库按照他自己本身的处理能力到rabbitmq中去取消息.

## 实现

用户下单——》服务器接受——》检查redis中是否还有库存，用户是否重复购买（没有库存/存在订单缓存，返回）——》rredis缓存中的库存减一，响应结果，并入队——》mq后台消费，创建订单，订单加入Resid缓存，数据库库存减一——》订单生成之后，通知用户在规定时间内支付金额，否则购买失败


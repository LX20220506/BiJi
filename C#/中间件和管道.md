当客户端发送请求时，请求需要经过一系列的处理步骤，这些步骤可以通过 .NET Core 中的中间件和管道来实现。下面是关于 .NET Core 中间件和管道的笔记及示例代码。

1. 中间件是一个处理HTTP请求和响应的组件。每个中间件都可以访问HTTP请求和响应，并将请求传递到下一个中间件或终止请求。中间件可以用于添加身份验证、日志记录、缓存等功能。
2. 管道是一系列的中间件，用于按照特定的顺序处理HTTP请求和响应。在使用管道时，每个请求都会依次经过管道中的每个中间件，直到响应被返回给客户端。
3. 在ASP.NET Core中，可以通过以下方式来创建中间件：

```C#
public class MyMiddleware
{
    private readonly RequestDelegate _next;

    public MyMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Do something before calling the next middleware.
        await _next(context);
        // Do something after calling the next middleware.
    }
}
```

1. 在 ASP.NET Core中，可以通过以下方式来创建管道：

```c#
	var app = builder => {
    builder.UseMiddleware<MyMiddleware>();
    builder.UseMiddleware<OtherMiddleware>();
    // Add more middleware here.
};

app.UseMiddleware<MyMiddleware>();
```

1. 在ASP.NET Core中，每个中间件都可以访问当前HTTP上下文，以及通过该上下文的属性和方法来访问请求和响应。例如，可以通过以下方式在中间件中获取请求URL：

```C#
public async Task InvokeAsync(HttpContext context)
{
    var url = context.Request.Path;
    // Do something with the URL.
    await _next(context);
}
```

1. ASP.NET Core的中间件是可插拔的，因此您可以根据需要添加、移除或替换中间件。
2. 下面是一个简单的示例，说明如何使用中间件和管道来创建一个记录请求时间的功能：

```c#
public class TimingMiddleware
{
    private readonly RequestDelegate _next;

    public TimingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        await _next(context);
        stopwatch.Stop();

        var elapsedMilliseconds = stopwatch.ElapsedMilliseconds;
        Console.WriteLine($"Request took {elapsedMilliseconds} ms");
    }
}

var app = builder => {
    builder.UseMiddleware<TimingMiddleware>();
    // Add other middleware here.
};
```









创建有值类型参数的中间件

~~~c#
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;

namespace ConsoleApp2
{
    public class Sample04
    {
        // 创建中间件（约定形式）
        public class HelloMiddleware
        {
            private readonly RequestDelegate _next;
            private readonly string _content;
            private readonly bool _isToNext;

            public HelloMiddleware(RequestDelegate next, string content, bool isToNext = false)
            {
                _next = next;
                _content = content;
                _isToNext = isToNext;
            }

            public async Task InvokeAsync(HttpContext httpContext)
            {
                await httpContext.Response.WriteAsync($"Hello {_content}!\r\n");
                if (_isToNext) await _next(httpContext); // 执行下一步
            }
        }

        public static void Start()
        {

            var host = Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(builder => builder // 构建默认的 WebHost
                    .Configure(app => app
                        .UseMiddleware<HelloMiddleware>("Rick", true) // 启用中间件
                        .UseMiddleware<HelloMiddleware>("Motry") // 启用中间件
                    )
                ).Build();
            host.Run();
        }
    }
}
~~~





使用中间件，构建MVC

~~~C#
using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace ConsoleApp2
{
    public class Sample11
    {
        public class Test1{ }
        public class Test2{ }       
        public static void Start()
        {
            var host = Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(builder => builder // 构建默认 WebHost
                    .ConfigureServices(collection => collection // 配置服务
                        .AddSingleton<Test1>()
                        .AddSingleton<Test2>()
                        .AddControllersWithViews()) // 注册（添加）MVC框架中的控制器和视图引擎
                    .Configure(app=>app
                        .UseRouting() // 启动路由中间件
                        .UseEndpoints(routeBuilder => routeBuilder.MapControllers())) // 启用终结点中间件，并调用MapControllers方法 将请求映射到MVC控制器中的操作方法
                )
                .Build();
            
            host.Run();
        }
    }

    public class Startup
    {
        public void Configure(IApplicationBuilder app)
        {

        }

        public void ConfigureServices(IServiceCollection services)
        {

        }
    }

    public class HomeController : Controller
    {
        private readonly Sample11.Test1 _test1;

        public HomeController(Sample11.Test1 test1)
        {
            _test1 = test1;
        }

        [HttpGet("/")]
        public IActionResult Index()
        {
            ViewBag.Test1 = _test1;
            return View();
        }
    }
}
~~~

> AddControllersWithViews()：
>
> IWebHostBuilder的扩展方法；<font color="red">用于注册MVC框架中的控制器和视图引擎。</font>
>
> 它的作用是向应用程序添加MVC服务，并将控制器和视图引擎添加到服务容器中。当HTTP请求到达时，MVC框架会根据路由规则选择相应的控制器，并使用视图引擎生成响应内容。
>
> 该方法的实现原理主要涉及以下步骤：
>
> 1. 注册MVC服务
> 2. 注册控制器
> 3. 注册视图引擎
> 4. 配置MVC选项
>
> 在源码层面，`AddControllersWithViews`方法是通过调用`IMvcBuilder`接口的`AddMvcOptions`方法实现的。该方法内部调用了一系列其他方法，包括`AddControllersAsServices`、`AddViewLocalization`、`AddDataAnnotationsLocalization`等，以完成各个组件的注册和配置。
>
> <font color="red">简单概括执行过程如下：</font>
>
> 1. 实例化WebHostBuilder
> 2. 使用UseStartup注册启动类
> 3. 构建WebHost并运行
>
> 在应用程序启动时，`ConfigureServices`方法被调用，`AddControllersWithViews`方法被调用并将MVC相关组件添加到服务容器中。之后，`Configure`方法被调用，其中包含了路由、控制器和视图引擎的配置。当HTTP请求到达时，MVC框架会根据路由规则选择相应的控制器，并使用视图引擎生成响应内容。



> MapControllers()：
>
> IEndpointRouteBuilder扩展方法，<font color="red">用于将请求映射到MVC控制器中的操作方法。</font>
>
> 它的作用是在应用程序中添加一个路由规则，可以将HTTP请求映射到MVC控制器中的相应操作方法。通过这种方式，我们可以让应用程序响应不同的HTTP请求，并根据请求参数执行不同的操作。
>
> 该方法的实现原理主要涉及以下步骤：
>
> 1. 解析路由模板
> 2. 匹配路由模板和请求路径
> 3. 从请求中读取参数并绑定到控制器操作方法的参数中
>
> 在源码层面，`MapControllers()`方法是通过调用`IRouteBuilder`接口的`MapRoute`方法实现的。该方法内部会解析路由模板、匹配请求路径，并从请求中读取参数并绑定到控制器操作方法的参数中。
>
> <font color="red">简单概括执行过程如下：</font>
>
> 1. 在Startup.cs文件中使用MapController注册路由规则
> 2. 当HTTP请求到达时，MVC框架会根据路由规则选择相应的控制器操作方法
> 3. 从请求中读取参数并绑定到控制器操作方法的参数中
> 4. 控制器操作方法执行完成后，MVC框架会生成响应内容并返回给客户端
>
> 总之，`MapControllers()`方法是将HTTP请求与MVC控制器操作方法相关联的重要工具，它可以让我们轻松地构建基于MVC框架的Web应用程序。



> MapControllerRoute（）：
>
> IEndpointRouteBuilder扩展方法，<font color="red">是 ASP.NET Core 中用于将 URL 路由到 MVC 控制器的方法。它会创建一个路由规则，使得当请求 URL 与该规则匹配时，能够调用指定的控制器和操作方法。</font>
>
> 方法的原理是基于 ASP.NET Core 中的路由系统。在应用程序启动时，ASP.NET Core 会注册路由规则，并在请求到达时按照规则进行匹配。MapControllerRoute() 就是通过添加一个新的路由规则来实现将请求路由到指定的控制器和操作方法。
>
> 以下是 MapControllerRoute() 方法的源码示例：
>
> ```c#
> app.UseEndpoints(endpoints =>
> {
>     endpoints.MapControllerRoute(
>         name: "default",
>         pattern: "{controller}/{action}/{id?}",
>         defaults: new { controller = "Home", action = "Index" });
> });
> ```
>
> 在这个示例中，我们定义了一个名为 "default" 的路由规则，将控制器、操作方法和可选的 id 参数作为 URL 的一部分。如果没有提供 action 或 id 参数，则默认值为 "Index" 和 null。
>
> <font color="red">执行过程如下：</font>
>
> 1. 当应用程序启动时，建立路由表并将其存储在内存中。
> 2. 当收到 HTTP 请求时，ASP.NET Core 根据路由表中的规则尝试匹配请求 URL。
> 3. 如果找到匹配项，则调用与规则关联的控制器和操作方法处理请求。
> 4. 如果没有找到匹配项，则返回 HTTP 404 错误。
>
> 总之，MapControllerRoute() 方法是 ASP.NET Core 中用于将请求路由到 MVC 控制器的重要方法，它使用 ASP.NET Core 路由系统来实现控制器的调用。



MapControllerRoute() 和MapController()的区别

MapControllerRoute() 和 MapController() 都是 ASP.NET Core 中用于将请求路由到 MVC 控制器的方法，但它们的实现方式略有不同。

MapController() 方法会创建一个默认的路由规则，使得请求 URL 的第一部分（即控制器名称）可以直接映射到指定的控制器类。例如，如果请求 URL 为 "/Home/Index"，则将调用名为 HomeController 的控制器类的 Index() 方法来处理请求。这种方式非常简单，适用于大多数基本的应用程序，但不能支持复杂的 URL 地址。

MapControllerRoute() 方法则更加灵活，因为它允许您自定义路由规则。通过提供模式字符串和其他参数，您可以定义如何将 URL 映射到控制器和操作方法。这样可以更好地满足特定应用程序的需求，并提高应用程序的可扩展性。

因此，总的来说，如果您的应用程序需要简单的路由方式，则可以使用 MapController() 方法，而如果需要更复杂的路由方式，则可以使用 MapControllerRoute() 方法。